%code requires {
    #include "ast.hpp"
}

%{
#include <iostream>
#include <cstdlib>
#include <vector>
#include "symbol_table.hpp"
#include "codegen.hpp"
#include "ast_print.hpp"
#include "procedure_table.hpp"

ProcedureTable proctab;
std::vector<ProcParam> currentParams;
CodeGen gen(proctab);
SymbolTable symtab;
extern int yylineno;
int yylex(void);
void yyerror(const char *s);

Stmt* programAST = nullptr;
bool verbose = false;
char currentParamMode = 'T';
%}

%define parse.error verbose

/* ==== UNION ==== */
%union {
    long long num;
    char* id;
    Expr* expr;
    Stmt* stmt;
    int argCount;
    CondExpr* cond;
}

%type <argCount> args
%type <cond> condition
%type <expr> expression value
%type <stmt> command commands main
%type <id> identifier proc_call proc_head

/* ==== TOKENY ==== */
%token PROGRAM IS IN END PROCEDURE
%token IF THEN ELSE ENDIF
%token WHILE DO ENDWHILE
%token FOR FROM TO DOWNTO ENDFOR
%token REPEAT UNTIL
%token READ WRITE

%token ASSIGN NEQ LEQ GEQ
%token PLUS MINUS MUL DIV MOD
%token EQ LT GT

%token T I O

%token SEM COM COL LBR RBR LSB RSB

%token <num> NUM
%token <id>  PIDENTIFIER

/* ==== PRIORYTETY ==== */
%left PLUS MINUS
%left MUL DIV MOD

%%

/* ===== START ===== */
program_all
    : procedures main                                                       {if (verbose) std::cout << "[PARSE] program_all\n";
                                                                                programAST = $2;
                                                                                if (verbose) symtab.dump();

                                                                                if (verbose) std::cout << "\n=== AST (last statement) ===\n";
                                                                                gen.genStmt(programAST);
                                                                                gen.flush();
                                                                                //printStmt(lastStmt);
                                                                            }
    ;

procedures
    : procedures PROCEDURE proc_head IS declarations IN commands END        {if (verbose) std::cout << "[PARSE] procedures PROCEDURE IS decl IN\n";
                                                                                auto* body = static_cast<BlockStmt*>($7);
                                                                                proctab.defineBody($3, body);
                                                                                
                                                                                symtab.leaveScope();
                                                                                currentParams.clear();
                                                                            }
    | procedures PROCEDURE proc_head IS IN commands END                     {if (verbose) std::cout << "[PARSE] procedures PROCEDURE IS IN\n";
                                                                                auto* body = static_cast<BlockStmt*>($6);
                                                                                proctab.defineBody($3, body);
                                                                                
                                                                                symtab.leaveScope();
                                                                                currentParams.clear();
                                                                            }
    | /* empty */                                                           {if (verbose) std::cout << "[PARSE] procedures empty\n";}
    ;

main
    : PROGRAM IS declarations IN commands END                               {if (verbose) std::cout << "[PARSE] main program (with declarations)\n";
                                                                                $$ = $5;
                                                                            }
    | PROGRAM IS IN commands END                                            {if (verbose) std::cout << "[PARSE] main program (no declarations)\n";
                                                                                $$ = $4; 
                                                                            }
    ;

commands
    : commands command                                                      {if (verbose) std::cout << "[PARSE] commands with following command\n";
                                                                                auto block = static_cast<BlockStmt*>($1);
                                                                                block->stmts.emplace_back($2);
                                                                                $$ = block;
                                                                            }
    | command                                                               {if (verbose) std::cout << "[PARSE] commands with a command\n";
                                                                                auto block = new BlockStmt();
                                                                                block->stmts.emplace_back($1);
                                                                                $$ = block;
                                                                            }
    ;

command
    : identifier ASSIGN expression SEM                                      {if (verbose) std::cout << "[PARSE] command ASSIGN\n";
                                                                                $$ = new AssignStmt($1, std::unique_ptr<Expr>($3));
                                                                            }
    | IF condition THEN commands ELSE commands ENDIF                        {if (verbose) std::cout << "[PARSE] command IF THEN ELSE\n";
                                                                                $$ = new IfStmt(std::unique_ptr<CondExpr>($2),
                                                                                                std::unique_ptr<Stmt>($4),
                                                                                                std::unique_ptr<Stmt>($6));
                                                                            }
    | IF condition THEN commands ENDIF                                      {if (verbose) std::cout << "[PARSE] command IF THEN\n";
                                                                                $$ = new IfStmt(std::unique_ptr<CondExpr>($2),
                                                                                                std::unique_ptr<Stmt>($4));
                                                                            }
    | WHILE condition DO commands ENDWHILE                                  {if (verbose) std::cout << "[PARSE] command WHILE DO\n";
                                                                                $$ = new WhileStmt(std::unique_ptr<CondExpr>($2),
                                                                                                    std::unique_ptr<Stmt>($4));
                                                                            }
    | REPEAT commands UNTIL condition SEM                                   {if (verbose) std::cout << "[PARSE] command REPEAT UNTIL\n";
                                                                                $$ = new RepeatStmt(std::unique_ptr<Stmt>($2),
                                                                                                    std::unique_ptr<CondExpr>($4));
                                                                            }
    | FOR PIDENTIFIER FROM value TO value DO commands ENDFOR                {if (verbose) std::cout << "[PARSE] command FOR FROM TO DO\n";
                                                                                $$ = new ForStmt($2,
                                                                                                std::unique_ptr<Expr>($4),
                                                                                                std::unique_ptr<Expr>($6),
                                                                                                std::unique_ptr<Stmt>($8),
                                                                                                false);
                                                                            }
    | FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR            {if (verbose) std::cout << "[PARSE] command FOR FROM DOWNTO DO\n";
                                                                                $$ = new ForStmt($2,
                                                                                                std::unique_ptr<Expr>($4),
                                                                                                std::unique_ptr<Expr>($6),
                                                                                                std::unique_ptr<Stmt>($8),
                                                                                                true);
                                                                            }
    | proc_call SEM                                                         {if (verbose) std::cout << "[PARSE] command proc_call\n";
                                                                                $$ = new CallStmt($1);
                                                                            }
    | READ identifier SEM                                                   {if (verbose) std::cout << "[PARSE] command READ\n";
                                                                                $$ = new ReadStmt($2);
                                                                            }
    | WRITE value SEM                                                       {if (verbose) std::cout << "[PARSE] command WRITE\n";
                                                                                $$ = new WriteStmt(std::unique_ptr<Expr>($2));
                                                                            }
    ;

proc_head
    : PIDENTIFIER                                                           {
                                                                                symtab.enterScope();
                                                                                currentParams.clear();
                                                                            } 
      LBR args_decl RBR                                                     {if (verbose) std::cout << "[PARSE] proc_head PIDENTIFIER(args_decl)\n";
                                                                                if (!proctab.declareProcedure($1, currentParams)) {
                                                                                    yyerror("Procedure redeclared");
                                                                                }
                                                                                $$ = $1;
                                                                            }
    ;

proc_call
    : PIDENTIFIER LBR args RBR                                              {if (verbose) std::cout << "[PARSE] proc_call PIDENTIFIER(args)\n";
                                                                                const auto* proc = proctab.lookup($1);
                                                                                if (!proc) {
                                                                                    yyerror("Call to undeclared procedure");
                                                                                }
                                                                                if (proc->params.size() != static_cast<size_t>($3)) {
                                                                                    yyerror("Wrong number of procedure arguments");
                                                                                }

                                                                                $$ = $1;
                                                                            }
    ;

declarations
    : declarations COM PIDENTIFIER                                          {if (verbose) std::cout << "[PARSE] declarations with more PID\n";
                                                                                if (!symtab.declareVariable($3)) {
                                                                                    yyerror("Variable redeclared");
                                                                                }
                                                                            }   
    | declarations COM PIDENTIFIER LSB NUM COL NUM RSB                      {if (verbose) std::cout << "[PARSE] declarations with more PID[]\n";
                                                                                if (!symtab.declareArray($3, $5, $7)) {
                                                                                    yyerror("Array redeclared or invalid range");
                                                                                }
                                                                            }
    | PIDENTIFIER                                                           {if (verbose) std::cout << "[PARSE] declarations with last PID\n";
                                                                                if (!symtab.declareVariable($1)) {
                                                                                    yyerror("Variable redeclared");
                                                                                }
                                                                            }
    | PIDENTIFIER LSB NUM COL NUM RSB                                       {if (verbose) std::cout << "[PARSE] declarations with last PID[]\n";
                                                                                if (!symtab.declareArray($1, $3, $5)) {
                                                                                    yyerror("Array redeclared or invalid range");
                                                                                }
                                                                            }
    ;

args_decl
    : args_decl COM type PIDENTIFIER                                        {if (verbose) std::cout << "[PARSE] args_decl with more PID\n";
                                                                                currentParams.push_back({currentParamMode, $4});
                                                                                symtab.declareVariable($4); // parametr = zmienna w scope procedury
                                                                            }
    | type PIDENTIFIER                                                      {if (verbose) std::cout << "[PARSE] args_decl with last PID\n";
                                                                                currentParams.push_back({currentParamMode, $2});
                                                                                symtab.declareVariable($2);
                                                                            }
    ;

type
    : /* empty */                                                           {if (verbose) std::cout << "[PARSE] type empty\n";}
    | T                                                                     {if (verbose) std::cout << "[PARSE] type T\n"; currentParamMode = 'T';}
    | I                                                                     {if (verbose) std::cout << "[PARSE] type I\n"; currentParamMode = 'I';}
    | O                                                                     {if (verbose) std::cout << "[PARSE] type O\n"; currentParamMode = 'O';}
    ;

args
    : args COM PIDENTIFIER                                                  {if (verbose) std::cout << "[PARSE] args with more PID\n";
                                                                                $$ = $1 + 1;
                                                                            }
    | PIDENTIFIER                                                           {if (verbose) std::cout << "[PARSE] args with last PID\n";
                                                                                $$ = 1;
                                                                            }
    ;

expression
    : value                                                                 {if (verbose) std::cout << "[PARSE] expression value\n";
                                                                                $$ = $1;
                                                                            }
    | value PLUS value                                                      {if (verbose) std::cout << "[PARSE] expression PLUS\n";
                                                                                $$ = new BinExpr(BinOp::ADD,
                                                                                                    std::unique_ptr<Expr>($1),
                                                                                                    std::unique_ptr<Expr>($3));
                                                                            }
    | value MINUS value                                                     {if (verbose) std::cout << "[PARSE] expression MINUS\n";
                                                                                $$ = new BinExpr(BinOp::SUB,
                                                                                                    std::unique_ptr<Expr>($1),
                                                                                                    std::unique_ptr<Expr>($3));
                                                                            }
    | value MUL value                                                       {if (verbose) std::cout << "[PARSE] expression MUL\n";
                                                                            $$ = new BinExpr(BinOp::MUL,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value DIV value                                                       {if (verbose) std::cout << "[PARSE] expressiion DIV\n";
                                                                            $$ = new BinExpr(BinOp::DIV,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value MOD value                                                       {if (verbose) std::cout << "[PARSE] expression MOD\n";
                                                                            $$ = new BinExpr(BinOp::MOD,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    ;

condition
    : value EQ value                                                        {if (verbose) std::cout << "[PARSE] condition EQ\n";
                                                                                $$ = new CondExpr(CondOp::EQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value NEQ value                                                       {if (verbose) std::cout << "[PARSE] condiition NEQ\n";
                                                                                $$ = new CondExpr(CondOp::NEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value GT value                                                        {if (verbose) std::cout << "[PARSE] condition GT\n";
                                                                                $$ = new CondExpr(CondOp::GT,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value LT value                                                        {if (verbose) std::cout << "[PARSE] condiition LT\n";
                                                                                $$ = new CondExpr(CondOp::LT,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value GEQ value                                                       {if (verbose) std::cout << "[PARSE] condiition GEQ\n";
                                                                                $$ = new CondExpr(CondOp::GEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value LEQ value                                                       {if (verbose) std::cout << "[PARSE] condition LEQ\n";
                                                                                $$ = new CondExpr(CondOp::LEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    ;

value
    : NUM                                                                   {if (verbose) std::cout << "[PARSE] value NUM\n";
                                                                                $$ = new ConstExpr($1);
                                                                            }
    | identifier                                                            {if (verbose) std::cout << "[PARSE] value identifier\n";
                                                                                $$ = new VarExpr($1);
                                                                            }
    ;

identifier
    : PIDENTIFIER                                                           {if (verbose) std::cout << "[PARSE] identifier PID\n";
                                                                                $$ = $1;
                                                                                if (!symtab.lookup($1)) {
                                                                                    yyerror("Use of undeclared variable");
                                                                                }
                                                                            }
    | PIDENTIFIER LSB PIDENTIFIER RSB                                       {if (verbose) std::cout << "[PARSE] identifier [PID]\n";
                                                                                $$ = $1;
                                                                                auto sym = symtab.lookup($1);
                                                                                if (!sym) yyerror("Use of undeclared array");
                                                                                if (sym->kind != SymbolKind::ARRAY) yyerror("Indexing non-array");

                                                                                // indeks jest zmienną → NIE sprawdzamy zakresu
                                                                                if (!symtab.lookup($3)) {
                                                                                    yyerror("Use of undeclared variable as array index");
                                                                                }
                                                                            }
    | PIDENTIFIER LSB NUM RSB                                               {if (verbose) std::cout << "[PARSE] identifier [NUM]\n";
                                                                                $$ = $1;
                                                                                auto sym = symtab.lookup($1);
                                                                                if (!sym) {
                                                                                    yyerror("Use of undeclared array");
                                                                                }
                                                                                if (sym->kind != SymbolKind::ARRAY) {
                                                                                    yyerror("Indexing non-array");
                                                                                }
                                                                                if ($3 < sym->start || $3 > sym->end)
                                                                                    yyerror("Array index out of bounds");
                                                                            }
    ;

%%

void yyerror(const char *s) {
    std::cerr << "SYNTAX ERROR line "
              << yylineno << ": " << s << std::endl;
    exit(1);
}