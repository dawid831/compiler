%code requires {
    #include "ast.hpp"
}

%{
#include <iostream>
#include <cstdlib>
#include <vector>
#include "symbol_table.hpp"
#include "codegen.hpp"
#include "ast_print.hpp"
#include "procedure_table.hpp"

ProcedureTable proctab;
std::vector<ProcParam> currentParams;
CodeGen gen(proctab);
SymbolTable symtab;
extern int yylineno;
int yylex(void);
void yyerror(const char *s);
static std::vector<std::string> forIterStack;

static bool isForIterator(const std::string& name) {
    for (auto it = forIterStack.rbegin(); it != forIterStack.rend(); ++it)
        if (*it == name) return true;
    return false;
}
Stmt* programAST = nullptr;
bool verbose = false;
char currentParamMode = 'T';
%}

%define parse.error verbose

/* ==== UNION ==== */
%union {
    long long num;
    char* id;
    Expr* expr;
    Stmt* stmt;
    BlockStmt* block;
    CondExpr* cond;
    std::vector<char*>* idlist;
}

%type <idlist> args
%type <cond> condition
%type <expr> expression value identifier
%type <stmt> command main proc_call
%type <block> commands
%type <id> proc_head
%type <num> for_dir

/* ==== TOKENY ==== */
%token PROGRAM IS IN END PROCEDURE
%token IF THEN ELSE ENDIF
%token WHILE DO ENDWHILE
%token FOR FROM TO DOWNTO ENDFOR
%token REPEAT UNTIL
%token READ WRITE

%token ASSIGN NEQ LEQ GEQ
%token PLUS MINUS MUL DIV MOD
%token EQ LT GT

%token T I O

%token SEM COM COL LBR RBR LSB RSB

%token <num> NUM
%token <id>  PIDENTIFIER

/* ==== PRIORYTETY ==== */
%left PLUS MINUS
%left MUL DIV MOD

%%

/* ===== START ===== */
program_all
    : procedures main                                                       {if (verbose) std::cout << "[PARSE] program_all\n";
                                                                                programAST = $2;
                                                                                if (verbose) symtab.dump();

                                                                                if (verbose) std::cout << "\n=== AST (last statement) ===\n";
                                                                                gen.genStmt(programAST);
                                                                                gen.finish();
                                                                                gen.flush();
                                                                                //printStmt(lastStmt);
                                                                            }
    ;

procedures
    : procedures PROCEDURE proc_head IS declarations IN commands END        {if (verbose) std::cout << "[PARSE] procedures PROCEDURE IS decl IN\n";
                                                                                auto* body = $7;
                                                                                proctab.defineBody($3, body);
                                                                                
                                                                                symtab.leaveScope();
                                                                                currentParams.clear();
                                                                            }
    | procedures PROCEDURE proc_head IS IN commands END                     {if (verbose) std::cout << "[PARSE] procedures PROCEDURE IS IN\n";
                                                                                auto* body = $6;
                                                                                proctab.defineBody($3, body);
                                                                                
                                                                                symtab.leaveScope();
                                                                                currentParams.clear();
                                                                            }
    | /* empty */                                                           {if (verbose) std::cout << "[PARSE] procedures empty\n";}
    ;

main
    : PROGRAM IS declarations IN commands END                               {if (verbose) std::cout << "[PARSE] main program (with declarations)\n";
                                                                                $$ = $5;
                                                                            }
    | PROGRAM IS IN commands END                                            {if (verbose) std::cout << "[PARSE] main program (no declarations)\n";
                                                                                $$ = $4; 
                                                                            }
    ;

commands
    : commands command                                                      {if (verbose) std::cout << "[PARSE] commands with following command\n";
                                                                                auto block = $1;
                                                                                block->stmts.emplace_back($2);
                                                                                $$ = block;
                                                                            }
    | command                                                               {if (verbose) std::cout << "[PARSE] commands with a command\n";
                                                                                auto block = new BlockStmt();
                                                                                block->stmts.emplace_back($1);
                                                                                $$ = block;
                                                                            }
    ;

for_dir
    : TO     { $$ = 0; }
    | DOWNTO { $$ = 1; }
    ;

command
    : identifier ASSIGN expression SEM                                      {if (verbose) std::cout << "[PARSE] command ASSIGN\n";
                                                                                auto v = static_cast<VarExpr*>($1);

                                                                                if (isForIterator(v->name))
                                                                                    yyerror("Modification of FOR iterator");

                                                                                $$ = new AssignStmt(v, std::unique_ptr<Expr>($3));
                                                                            }
    | IF condition THEN commands ELSE commands ENDIF                        {if (verbose) std::cout << "[PARSE] command IF THEN ELSE\n";
                                                                                $$ = new IfStmt(std::unique_ptr<CondExpr>($2),
                                                                                                std::unique_ptr<Stmt>($4),
                                                                                                std::unique_ptr<Stmt>($6));
                                                                            }
    | IF condition THEN commands ENDIF                                      {if (verbose) std::cout << "[PARSE] command IF THEN\n";
                                                                                $$ = new IfStmt(std::unique_ptr<CondExpr>($2),
                                                                                                std::unique_ptr<Stmt>($4));
                                                                            }
    | WHILE condition DO commands ENDWHILE                                  {if (verbose) std::cout << "[PARSE] command WHILE DO\n";
                                                                                $$ = new WhileStmt(std::unique_ptr<CondExpr>($2),
                                                                                                    std::unique_ptr<Stmt>($4));
                                                                            }
    | REPEAT commands UNTIL condition SEM                                   {if (verbose) std::cout << "[PARSE] command REPEAT UNTIL\n";
                                                                                $$ = new RepeatStmt(std::unique_ptr<Stmt>($2),
                                                                                                    std::unique_ptr<CondExpr>($4));
                                                                            }
    | FOR PIDENTIFIER
    {
        symtab.enterScope();
        symtab.declareVariable($2);
        forIterStack.push_back($2);
    }
    FROM value for_dir value DO commands ENDFOR
    {
        const Symbol* itSym = symtab.lookup($2);
if (!itSym) yyerror("INTERNAL: missing FOR iterator");

$$ = new ForStmt(itSym->uid,
                std::unique_ptr<Expr>($5),
                std::unique_ptr<Expr>($7),
                std::unique_ptr<Stmt>($9),
                $6 == 1);

    }
    | proc_call SEM                                                         {if (verbose) std::cout << "[PARSE] command proc_call\n";
                                                                                $$ = $1;
                                                                            }
    | READ identifier SEM                                                   {if (verbose) std::cout << "[PARSE] command READ\n";
                                                                                $$ = new ReadStmt(static_cast<VarExpr*>($2));
                                                                            }
    | WRITE value SEM                                                       {if (verbose) std::cout << "[PARSE] command WRITE\n";
                                                                                $$ = new WriteStmt(std::unique_ptr<Expr>($2));
                                                                            }
    ;

proc_head
    : PIDENTIFIER                                                           {
                                                                                symtab.enterScope();
                                                                                currentParams.clear();
                                                                            } 
      LBR args_decl RBR                                                     {if (verbose) std::cout << "[PARSE] proc_head PIDENTIFIER(args_decl)\n";
                                                                                if (!proctab.declareProcedure($1, currentParams)) {
                                                                                    yyerror("Procedure redeclared");
                                                                                }
                                                                                $$ = $1;
                                                                            }
    ;

proc_call
    : PIDENTIFIER LBR args RBR                                              {
          const auto* proc = proctab.lookup($1);
          if (!proc) yyerror("Call to undeclared procedure");
          if (proc->params.size() != $3->size())
              yyerror("Wrong number of procedure arguments");

          std::vector<std::string> callArgs;
          callArgs.reserve($3->size());
          for (char* s : *$3) callArgs.emplace_back(s);

          $$ = new CallStmt(std::string($1), std::move(callArgs));

          delete $3;
      }
    ;

declarations
    : declarations COM PIDENTIFIER                                          {if (verbose) std::cout << "[PARSE] declarations with more PID\n";
                                                                                if (!symtab.declareVariable($3)) {
                                                                                    yyerror("Variable redeclared");
                                                                                }
                                                                            }   
    | declarations COM PIDENTIFIER LSB NUM COL NUM RSB                      {if (verbose) std::cout << "[PARSE] declarations with more PID[]\n";
                                                                                if (!symtab.declareArray($3, $5, $7)) {
                                                                                    yyerror("Array redeclared or invalid range");
                                                                                }
                                                                            }
    | PIDENTIFIER                                                           {if (verbose) std::cout << "[PARSE] declarations with last PID\n";
                                                                                if (!symtab.declareVariable($1)) {
                                                                                    yyerror("Variable redeclared");
                                                                                }
                                                                            }
    | PIDENTIFIER LSB NUM COL NUM RSB                                       {if (verbose) std::cout << "[PARSE] declarations with last PID[]\n";
                                                                                if (!symtab.declareArray($1, $3, $5)) {
                                                                                    yyerror("Array redeclared or invalid range");
                                                                                }
                                                                            }
    ;

args_decl
    : args_decl COM type PIDENTIFIER                                        {if (verbose) std::cout << "[PARSE] args_decl with more PID\n";
                                                                                symtab.declareVariable($4);
                                                                                const Symbol* s = symtab.lookup($4);
                                                                                currentParams.push_back({currentParamMode, $4, s->uid});
                                                                            }
    | type PIDENTIFIER                                                      {if (verbose) std::cout << "[PARSE] args_decl with last PID\n";
                                                                                symtab.declareVariable($2);
                                                                                const Symbol* s = symtab.lookup($2);
                                                                                currentParams.push_back({currentParamMode, $2, s->uid});
                                                                            }
    ;

type
    : /* empty */                                                           {if (verbose) std::cout << "[PARSE] type empty\n";}
    | T                                                                     {if (verbose) std::cout << "[PARSE] type T\n"; currentParamMode = 'T';}
    | I                                                                     {if (verbose) std::cout << "[PARSE] type I\n"; currentParamMode = 'I';}
    | O                                                                     {if (verbose) std::cout << "[PARSE] type O\n"; currentParamMode = 'O';}
    ;

args
    : args COM PIDENTIFIER                                                  {if (verbose) std::cout << "[PARSE] args with more PID\n";
                                                                                if (symtab.lookup($3)->kind == SymbolKind::ARRAY)
                                                                                yyerror("Array passed as procedure argument");
                                                                                $1->push_back($3);
                                                                                $$ = $1;
                                                                            }
    | PIDENTIFIER                                                           {if (verbose) std::cout << "[PARSE] args with last PID\n";
                                                                                if (symtab.lookup($1)->kind == SymbolKind::ARRAY)
                                                                                yyerror("Array passed as procedure argument");
                                                                                $$ = new std::vector<char*>();
                                                                                $$->push_back($1);
                                                                            }
    ;

expression
    : value                                                                 {if (verbose) std::cout << "[PARSE] expression value\n";
                                                                                $$ = $1;
                                                                            }
    | value PLUS value                                                      {if (verbose) std::cout << "[PARSE] expression PLUS\n";
                                                                                $$ = new BinExpr(BinOp::ADD,
                                                                                                    std::unique_ptr<Expr>($1),
                                                                                                    std::unique_ptr<Expr>($3));
                                                                            }
    | value MINUS value                                                     {if (verbose) std::cout << "[PARSE] expression MINUS\n";
                                                                                $$ = new BinExpr(BinOp::SUB,
                                                                                                    std::unique_ptr<Expr>($1),
                                                                                                    std::unique_ptr<Expr>($3));
                                                                            }
    | value MUL value                                                       {if (verbose) std::cout << "[PARSE] expression MUL\n";
                                                                            $$ = new BinExpr(BinOp::MUL,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value DIV value                                                       {if (verbose) std::cout << "[PARSE] expressiion DIV\n";
                                                                            $$ = new BinExpr(BinOp::DIV,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value MOD value                                                       {if (verbose) std::cout << "[PARSE] expression MOD\n";
                                                                            $$ = new BinExpr(BinOp::MOD,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    ;

condition
    : value EQ value                                                        {if (verbose) std::cout << "[PARSE] condition EQ\n";
                                                                                $$ = new CondExpr(CondOp::EQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value NEQ value                                                       {if (verbose) std::cout << "[PARSE] condiition NEQ\n";
                                                                                $$ = new CondExpr(CondOp::NEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value GT value                                                        {if (verbose) std::cout << "[PARSE] condition GT\n";
                                                                                $$ = new CondExpr(CondOp::GT,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value LT value                                                        {if (verbose) std::cout << "[PARSE] condiition LT\n";
                                                                                $$ = new CondExpr(CondOp::LT,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value GEQ value                                                       {if (verbose) std::cout << "[PARSE] condiition GEQ\n";
                                                                                $$ = new CondExpr(CondOp::GEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value LEQ value                                                       {if (verbose) std::cout << "[PARSE] condition LEQ\n";
                                                                                $$ = new CondExpr(CondOp::LEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    ;

value
    : NUM                                                                   {if (verbose) std::cout << "[PARSE] value NUM\n";
                                                                                $$ = new ConstExpr($1);
                                                                            }
    | identifier                                                            {if (verbose) std::cout << "[PARSE] value identifier\n";
                                                                                $$ = $1;
                                                                            }
    ;

identifier
    : PIDENTIFIER                                                           {if (verbose) std::cout << "[PARSE] identifier PID\n";
                                                                                const Symbol* sym = symtab.lookup($1);
                                                                                if (!sym) yyerror("Use of undeclared variable");
                                                                                $$ = new VarExpr($1, sym->uid);
                                                                            }
    | PIDENTIFIER LSB PIDENTIFIER RSB                                       {if (verbose) std::cout << "[PARSE] identifier [PID]\n";
                                                                                const Symbol* symArr = symtab.lookup($1);
                                                                                const Symbol* symIdx = symtab.lookup($3);
                                                                                if (!symArr) yyerror("Use of undeclared array");
                                                                                if (symArr->kind != SymbolKind::ARRAY) yyerror("Indexing non-array");
                                                                                if (!symIdx) yyerror("Use of undeclared variable");

                                                                                auto idx = std::make_unique<VarExpr>($3, symIdx->uid);
                                                                                auto* v  = new VarExpr($1, symArr->uid, std::move(idx));
                                                                                v->arrStart = symArr->start;
                                                                                v->arrEnd   = symArr->end;

                                                                                $$ = v;
                                                                            }
    | PIDENTIFIER LSB NUM RSB                                               {if (verbose) std::cout << "[PARSE] identifier [NUM]\n";
                                                                                const Symbol* symArr = symtab.lookup($1);
                                                                                if (!symArr) yyerror("Use of undeclared array");
                                                                                if (symArr->kind != SymbolKind::ARRAY) yyerror("Indexing non-array");

                                                                                auto idx = std::make_unique<ConstExpr>($3);
                                                                                auto* v  = new VarExpr($1, symArr->uid, std::move(idx));
                                                                                v->arrStart = symArr->start;
                                                                                v->arrEnd   = symArr->end;
                                                                                $$ = v;
                                                                            }
    ;

%%

void yyerror(const char *s) {
    std::cerr << "SYNTAX ERROR line "
              << yylineno << ": " << s << std::endl;
    exit(1);
}