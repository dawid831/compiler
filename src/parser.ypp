%code requires {
    #include "ast.hpp"
}

%{
#include <iostream>
#include <cstdlib>
#include <vector>
#include "symbol_table.hpp"
#include "codegen.hpp"
#include "procedure_table.hpp"

ProcedureTable proctab;
std::vector<ProcParam> currentParams;
CodeGen gen(proctab);
SymbolTable symtab;
extern int yylineno;
int yylex(void);
void yyerror(const char *s);
static std::vector<std::string> forIterStack;

static bool isForIterator(const std::string& name) {
    for (auto it = forIterStack.rbegin(); it != forIterStack.rend(); ++it)
        if (*it == name) return true;
    return false;
}
Stmt* programAST = nullptr;
char currentParamMode = ' ';
static std::string currentProcName;
%}

%define parse.error verbose

/* ==== UNION ==== */
%union {
    long long num;
    char* id;
    Expr* expr;
    Stmt* stmt;
    BlockStmt* block;
    CondExpr* cond;
    std::vector<char*>* idlist;
}

%type <idlist> args
%type <cond> condition
%type <expr> expression value identifier
%type <stmt> command main proc_call
%type <block> commands
%type <id> proc_head
%type <num> for_dir

/* ==== TOKENY ==== */
%token PROGRAM IS IN END PROCEDURE
%token IF THEN ELSE ENDIF
%token WHILE DO ENDWHILE
%token FOR FROM TO DOWNTO ENDFOR
%token REPEAT UNTIL
%token READ WRITE

%token ASSIGN NEQ LEQ GEQ
%token PLUS MINUS MUL DIV MOD
%token EQ LT GT

%token T I O

%token SEM COM COL LBR RBR LSB RSB

%token <num> NUM
%token <id>  PIDENTIFIER

/* ==== PRIORYTETY ==== */
%left PLUS MINUS
%left MUL DIV MOD

%%

/* ===== START ===== */
program_all
    : procedures main                                                       {
                                                                                programAST = $2;

                                                                                gen.allocateAllSymbols();
                                                                                //symtab.dumpNamesUidsAddrs();
                                                                                gen.genStmt(programAST);
                                                                                gen.finish();
                                                                                gen.flush();
                                                                            }
    ;

procedures
    : procedures PROCEDURE proc_head IS declarations IN commands END        {
                                                                                auto* body = $7;
                                                                                proctab.defineBody($3, body);

                                                                                symtab.leaveScope();
                                                                                currentParams.clear();
                                                                                currentProcName.clear();
                                                                            }
    | procedures PROCEDURE proc_head IS IN commands END                     {
                                                                                auto* body = $6;
                                                                                proctab.defineBody($3, body);

                                                                                symtab.leaveScope();
                                                                                currentParams.clear();
                                                                                currentProcName.clear();
                                                                            }
    | /* empty */                                                           {}
    ;

main
    : PROGRAM IS declarations IN commands END                               {
                                                                                $$ = $5;
                                                                            }
    | PROGRAM IS IN commands END                                            {
                                                                                $$ = $4; 
                                                                            }
    ;

commands
    : commands command                                                      {
                                                                                auto block = $1;
                                                                                block->stmts.emplace_back($2);
                                                                                $$ = block;
                                                                            }
    | command                                                               {
                                                                                auto block = new BlockStmt();
                                                                                block->stmts.emplace_back($1);
                                                                                $$ = block;
                                                                            }
    ;

for_dir
    : TO     { $$ = 0; }
    | DOWNTO { $$ = 1; }
    ;

command
    : identifier ASSIGN expression SEM                                      {
                                                                                auto v = static_cast<VarExpr*>($1);
                                                                                const Symbol* base = symtab.lookup(v->name);
                                                                                if (base && base->mode == 'I')
                                                                                    yyerror("Modification of I parameter");

                                                                                if (isForIterator(v->name))
                                                                                    yyerror("Modification of FOR iterator");

                                                                                if (base && base->mode == 'O') {
                                                                                    Symbol* mut = symtab.lookupMutable(v->name);
                                                                                    if (mut) mut->initialized = true;
                                                                                }

                                                                                $$ = new AssignStmt(v, std::unique_ptr<Expr>($3));
                                                                            }
    | IF condition THEN commands ELSE commands ENDIF                        {
                                                                                $$ = new IfStmt(std::unique_ptr<CondExpr>($2),
                                                                                                std::unique_ptr<Stmt>($4),
                                                                                                std::unique_ptr<Stmt>($6));
                                                                            }
    | IF condition THEN commands ENDIF                                      {
                                                                                $$ = new IfStmt(std::unique_ptr<CondExpr>($2),
                                                                                                std::unique_ptr<Stmt>($4));
                                                                            }
    | WHILE condition DO commands ENDWHILE                                  {
                                                                                $$ = new WhileStmt(std::unique_ptr<CondExpr>($2),
                                                                                                    std::unique_ptr<Stmt>($4));
                                                                            }
    | REPEAT commands UNTIL condition SEM                                   {
                                                                                $$ = new RepeatStmt(std::unique_ptr<Stmt>($2),
                                                                                                    std::unique_ptr<CondExpr>($4));
                                                                            }
    | FOR PIDENTIFIER                                                       {
                                                                                symtab.enterScope();

                                                                                if (!symtab.declareVariable($2, ' ', false))
                                                                                    yyerror("FOR iterator redeclared");

                                                                                forIterStack.push_back($2);
                                                                            }
    FROM value for_dir value DO commands ENDFOR                             {
                                                                                const Symbol* itSym = symtab.lookup($2);
                                                                                if (!itSym) yyerror("INTERNAL: missing FOR iterator");

                                                                                $$ = new ForStmt(
                                                                                    $2,
                                                                                    itSym->uid,
                                                                                    std::unique_ptr<Expr>($5),
                                                                                    std::unique_ptr<Expr>($7),
                                                                                    std::unique_ptr<Stmt>($9),
                                                                                    $6 == 1
                                                                                );

                                                                                forIterStack.pop_back();
                                                                                symtab.leaveScope();
                                                                            }
    | proc_call SEM                                                         {
                                                                                $$ = $1;
                                                                            }
    | READ identifier SEM                                                   {
                                                                                auto v = static_cast<VarExpr*>($2);
                                                                                const Symbol* base = symtab.lookup(v->name);
                                                                                if (base && base->mode == 'I') yyerror("READ into I parameter");
                                                                                if (base && base->mode == 'O') {
                                                                                    Symbol* mut = symtab.lookupMutable(v->name);
                                                                                    if (mut) mut->initialized = true;
                                                                                }
                                                                                $$ = new ReadStmt(v);
                                                                            }
    | WRITE value SEM                                                       {
                                                                                $$ = new WriteStmt(std::unique_ptr<Expr>($2));
                                                                            }
    ;

proc_head
    : PIDENTIFIER                                                           {
                                                                                symtab.enterScope(); 
                                                                                currentParams.clear();
                                                                                currentParamMode = ' ';
                                                                                currentProcName = $1;
                                                                            } 
      LBR args_decl RBR                                                     {
                                                                                if (!proctab.declareProcedure($1, currentParams)) {
                                                                                    yyerror("Procedure redeclared");
                                                                                }
                                                                                $$ = $1;
                                                                            }
    ;

proc_call
    : PIDENTIFIER LBR args RBR                                              {
          const auto* proc = proctab.lookup($1);
          if (!proc) yyerror("Call to undeclared procedure");
          if (proc->params.size() != $3->size())
              yyerror("Wrong number of procedure arguments");

          // Zakaz bezpośredniej rekurencji
          if (!currentProcName.empty() && currentProcName == std::string($1))
              yyerror("Recursive procedure call");

          // Sprawdzenie zgodności argumentów z parametrami (T vs scalar, I/O)
          for (size_t i = 0; i < proc->params.size(); ++i) {
              const ProcParam& fp = proc->params[i];
              const char* aname = (*$3)[i];
              const Symbol* as = symtab.lookup(aname);
              if (!as) yyerror("Use of undeclared variable");

              // T -> musi być tablica
              if (fp.mode == 'T') {
                  if (as->kind != SymbolKind::ARRAY) yyerror("Expected array argument");
              } else {
                  if (as->kind != SymbolKind::VARIABLE) yyerror("Expected scalar argument");
              }

              // I-argumenty w procedurze wywołującej można przekazywać tylko do I
              if (as->mode == 'I' && fp.mode != 'I')
                  yyerror("I parameter can be passed only to I formal parameter");

              // O nie można podać w miejsce I
              if (as->mode == 'O' && fp.mode == 'I')
                  yyerror("O parameter cannot be passed to I formal parameter");

              // Po wywołaniu parametr OUT (O) staje się zainicjalizowany w kontekście wywołującego
              if (fp.mode == 'O') {
                  Symbol* mut = symtab.lookupMutable(aname);
                  if (mut) mut->initialized = true;
              }
          }

          std::vector<CallArg> callArgs;
            callArgs.reserve($3->size());

            for (char* anameC : *$3) {
                std::string aname(anameC);
                const Symbol* as = symtab.lookup(aname);
                if (!as) yyerror("Use of undeclared variable");

                CallArg ca;
                ca.uid = as->uid;
                ca.isArray = (as->kind == SymbolKind::ARRAY);
                ca.start = as->start;
                ca.end   = as->end;
                callArgs.push_back(ca);
            }

            $$ = new CallStmt(std::string($1), std::move(callArgs));
            delete $3;
      }
    ;

declarations
    : declarations COM PIDENTIFIER                                          {
                                                                                if (!symtab.declareVariable($3)) {
                                                                                    yyerror("Variable redeclared");
                                                                                }
                                                                            }   
    | declarations COM PIDENTIFIER LSB NUM COL NUM RSB                      {
                                                                                if (!symtab.declareArray($3, $5, $7)) {
                                                                                    yyerror("Array redeclared or invalid range");
                                                                                }
                                                                            }
    | PIDENTIFIER                                                           {
                                                                                if (!symtab.declareVariable($1)) {
                                                                                    yyerror("Variable redeclared");
                                                                                }
                                                                            }
    | PIDENTIFIER LSB NUM COL NUM RSB                                       {
                                                                                if (!symtab.declareArray($1, $3, $5)) {
                                                                                    yyerror("Array redeclared or invalid range");
                                                                                }
                                                                            }
    ;

args_decl
    : args_decl COM type PIDENTIFIER                                        {
                                                                                if (currentParamMode == 'T') {
                                                                                    symtab.declareArray($4, 0, 0, 'T');
                                                                                } else {
                                                                                    bool init = (currentParamMode != 'O');
                                                                                    if (!symtab.declareVariable($4, currentParamMode, init))
                                                                                        yyerror("Parameter redeclared");
                                                                                }
                                                                                const Symbol* s = symtab.lookup($4);
                                                                                currentParams.push_back({currentParamMode, $4, s->uid});
                                                                            }
    | type PIDENTIFIER                                                      {
                                                                                if (currentParamMode == 'T') {
                                                                                    symtab.declareArray($2, 0, 0, 'T');
                                                                                } else {
                                                                                    bool init = (currentParamMode != 'O');
                                                                                    symtab.declareVariable($2, currentParamMode, init);
                                                                                }
                                                                                const Symbol* s = symtab.lookup($2);
                                                                                currentParams.push_back({currentParamMode, $2, s->uid});
                                                                            }
    ;

type
    : /* empty */                                                           { currentParamMode = ' '; }
    | T                                                                     { currentParamMode = 'T'; }
    | I                                                                     { currentParamMode = 'I'; }
    | O                                                                     { currentParamMode = 'O'; }
    ;


args
    : args COM PIDENTIFIER                                                  {
                                                                                if (!symtab.lookup($3)) yyerror("Use of undeclared variable");
                                                                                $1->push_back($3);
                                                                                $$ = $1;
                                                                            }
    | PIDENTIFIER                                                           {
                                                                                if (!symtab.lookup($1)) yyerror("Use of undeclared variable");
                                                                                $$ = new std::vector<char*>();
                                                                                $$->push_back($1);
                                                                            }
    ;

expression
    : value                                                                 {
                                                                                $$ = $1;
                                                                            }
    | value PLUS value                                                      {
                                                                                $$ = new BinExpr(BinOp::ADD,
                                                                                                    std::unique_ptr<Expr>($1),
                                                                                                    std::unique_ptr<Expr>($3));
                                                                            }
    | value MINUS value                                                     {
                                                                                $$ = new BinExpr(BinOp::SUB,
                                                                                                    std::unique_ptr<Expr>($1),
                                                                                                    std::unique_ptr<Expr>($3));
                                                                            }
    | value MUL value                                                       {
                                                                            $$ = new BinExpr(BinOp::MUL,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value DIV value                                                       {
                                                                            $$ = new BinExpr(BinOp::DIV,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value MOD value                                                       {
                                                                            $$ = new BinExpr(BinOp::MOD,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    ;

condition
    : value EQ value                                                        {
                                                                                $$ = new CondExpr(CondOp::EQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value NEQ value                                                       {
                                                                                $$ = new CondExpr(CondOp::NEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value GT value                                                        {
                                                                                $$ = new CondExpr(CondOp::GT,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value LT value                                                        {
                                                                                $$ = new CondExpr(CondOp::LT,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value GEQ value                                                       {
                                                                                $$ = new CondExpr(CondOp::GEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    | value LEQ value                                                       {
                                                                                $$ = new CondExpr(CondOp::LEQ,
                                                                                                std::unique_ptr<Expr>($1),
                                                                                                std::unique_ptr<Expr>($3));
                                                                            }
    ;

value
    : NUM                                                                   {
                                                                                $$ = new ConstExpr($1);
                                                                            }
    | identifier                                                            {
                                                                                // nie wolno czytać parametru O przed inicjalizacją
                                                                                if (auto v = dynamic_cast<VarExpr*>($1)) {
                                                                                    const Symbol* s = symtab.lookup(v->name);
                                                                                    if (s && s->mode == 'O' && !s->initialized)
                                                                                        yyerror("Read of O parameter before initialization");
                                                                                }
                                                                                $$ = $1;
                                                                            }
    ;

identifier
    : PIDENTIFIER                                                           {
                                                                                const Symbol* sym = symtab.lookup($1);
                                                                                if (!sym) yyerror("Use of undeclared variable");
                                                                                $$ = new VarExpr($1, sym->uid);
                                                                            }
    | PIDENTIFIER LSB PIDENTIFIER RSB                                       {
                                                                                const Symbol* symArr = symtab.lookup($1);
                                                                                const Symbol* symIdx = symtab.lookup($3);
                                                                                if (!symArr) yyerror("Use of undeclared array");
                                                                                if (symArr->kind != SymbolKind::ARRAY) yyerror("Indexing non-array");
                                                                                if (!symIdx) yyerror("Use of undeclared variable");
                                                                                if (symIdx->mode == 'O' && !symIdx->initialized)
                                                                                    yyerror("Read of O parameter before initialization");

                                                                                auto idx = std::make_unique<VarExpr>($3, symIdx->uid);
                                                                                auto* v  = new VarExpr($1, symArr->uid, std::move(idx));
                                                                                v->arrStart = symArr->start;
                                                                                v->arrEnd   = symArr->end;

                                                                                $$ = v;
                                                                            }
    | PIDENTIFIER LSB NUM RSB                                               {
                                                                                const Symbol* symArr = symtab.lookup($1);
                                                                                if (!symArr) yyerror("Use of undeclared array");
                                                                                if (symArr->kind != SymbolKind::ARRAY) yyerror("Indexing non-array");

                                                                                auto idx = std::make_unique<ConstExpr>($3);
                                                                                auto* v  = new VarExpr($1, symArr->uid, std::move(idx));
                                                                                v->arrStart = symArr->start;
                                                                                v->arrEnd   = symArr->end;
                                                                                $$ = v;
                                                                            }
    ;

%%

void yyerror(const char *s) {
    std::cerr << "SYNTAX ERROR line "
              << yylineno << ": " << s << std::endl;
    exit(1);
}